今天工作涉及到不同时间计算方式的转换问题，发现对时间标准这块知道的太少了。想想还是有必要了解一下的，万一以后再遇到呢！
想知道如何去转换那得了解各时间标准，那才能知道如何去计算。


#####先来了解下GMT和UTC

>以下摘至百度百科

#### 格林尼治标准时（GMT）

格林尼治标准时间（Greenwich Mean Time，GMT）是指位于伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能和实际的太阳时相差16分钟。 地球每天的自转是有些不规则的，而且正在缓慢减速。所以，格林尼治时间已经不再被作为标准时间使用。现在的标准时间——协调世界时（UTC）——由原子钟提供。 自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。而UTC是基于标准的GMT提供的准确时间。
GMT（Greenwich Mean Time）——格林尼治标准时间，格林尼治标准时间是19 世纪中叶大英帝国的基准时间，同时也是事实上的世界基准时间。当时主要为了1840 年之后的铁路系统服务。它以格林尼治天文台的经线为0 度经线，将世界分为24 个时区，除了在特定时期受到仇外心理、民族主义和某些反英心绪的影响之外，它的地位一直未曾动摇。

#### GMT和UTC的区别
GMT 手表就是可以显示两个或两个以上时区时间的手表。无论用什么方式，显示多个时区最直接的方法就是在一个表壳里装多枚机芯。不过最经济也最常见的方法还是附加一个带有12 小时或24 小时时标刻度的旋转表圈。旋转表圈的使用方法很简单，将表圈上对应第二时区时间的数字对齐表盘的时针即可，如果表盘时间是伦敦时间，那么将表圈顺时针转动一小时，指示的就是欧洲大陆时间，逆时针转动八小时，则是美国西海岸时间。
将表盘时间设定为家乡时间还是目的地时间取决于使用者的偏好，但由于12 小时手表无法辨别白天晚上，通常还是设定所在地时间比较合理。有一个事件的发生使得GMT 的定义复杂化了：1972 年1 月1日，UTC（协调世界时）成为新的世界标准时间。
为了方便， 通常记成Universal Time Coordinated。同样为了方便，在不需要精确到秒的情况下，通常也将GMT 和UTC 视作等同。尽管UTC 更加科学更加精确，但是对于手表玩家和收藏者来说，GMT 仍是更加受欢迎的。有不少人认为，UTC 是巴黎图谋世界计时中心地位的一种手段。事实上，它是以原子时为基础，在时刻上尽量接近世界时的一种时间计量系统。它的出现是现代社会对于精确计时的需要。
原子时与以往的计时系统不同，它非常精确并且不以某地的平均太阳时为基准，但是遇有地球自转速度不均匀，原子时与世界时之间的时差便日积月累，因 此，UTC 会在一段时期后加上正或负的闰秒来补偿。因此协调世界时与国际原子时(TAI) 之间会出现若干整数秒的差别。位于巴黎的国际地球自转事务中央局(IERS) 负责决定何时加入闰秒。

#### UNIX时间

UNIX时间，，是方式：从协调世界时1970年1月1日0时0分0秒起的总秒数，

好吧，原来时间计算也是有这么深刻的故事的。

#####说下今天遇到的问题
需要把C#中的一个tick时间戳转为java中的时间，而给C#中的时间戳是0001 年 1 月 1 日午夜 12:00开始，以来所经过时间以100 毫微秒为间隔表示时的数字，java中的时间是使用UNIX时间（也就是协调世界时）是从1970年1月1号开始计算的。

所以我的思路是这样的
--->把C#时间减去0001年到1970年的所经过的时间
--->此时单位仍是100 毫微秒,除以10000
--->得到单位为毫秒
--->转为java时间，打印，发现时间早8小时，于是想到的时区
--->再减去8小时
--->发现对了

如下是一个C#中时间戳
`2016/5/17 11:07:52`
`635990800723902949`
计算方式

        long unixTime = (635990800723902949L-621355968000000000L)/10000-8*60*60*1000;
        new Date(unixTime);

这时时间就对上了。
