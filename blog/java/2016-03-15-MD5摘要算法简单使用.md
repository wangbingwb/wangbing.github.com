最近经常用到MD5加密，所以觉得有必要好好了解一下原理，与生成方法。
MD5算法其实信息摘要算法，它接受任意大小的数据生成固定长度的哈希值。理论上加密数据无数个，生成的数列却是固定的，会出现重复值。但在工程学认为：错误概率低到一定程度就可以认为是工程可靠的。不过MD5还是适合一些简短的文本加密。
java中有MessageDigest这个类帮助处理数据。
MessageDigest不是new出来的，而是通过MessageDigest的静态方法getInstance("")实例化出来的。
```java
MessageDigest md5 = MessageDigest.getInstance("MD5");
```

通过update（）来处理字符
```java
md5.update("123456".getBytes());
```

通过digest()生成摘要
```java
byte[] digest = md5.digest();
```

得到的字节数组不易存贮，一般是转为16进制字符来存储。
一个字节占8bit，而4bit可以用一个16进制字符来表示。也就是一个字节可以转2个16进制字符。
0000 0000  ->  0 0
0001 0001  ->  1 1
0002 0002  ->  2 2
.
.
.
1110 1110  -> E E
1111 1111  -> F F

这里涉及一些位运算
字节的前4位： b>>4 & 0xf
字节的后4位： b & 0xf

#### 因此可以使用下面的转法：
```java
    StringBuffer sb = new StringBuffer();
    for (byte b : digest) {
        sb.append(Integer.toHexString(b>>4 & 0xf));
        sb.append(Integer.toHexString(b & 0xf));
    }
```

#### 输出拼接的字符
```java
   e10adc3949ba59abbe56e057f20f883e
```


#### 完整实例
```java

	MessageDigest md5 = MessageDigest.getInstance("MD5");
	md5.update("123456".getBytes());
	byte[] digest = md5.digest();

	StringBuffer sb = new StringBuffer();
	for (byte b : digest) {
		sb.append(Integer.toHexString(b>>4 & 0xf));
		sb.append(Integer.toHexString(b & 0xf));
	}
	System.out.println(sb.toString());

```


