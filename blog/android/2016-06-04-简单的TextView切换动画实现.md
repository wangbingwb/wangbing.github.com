原生的TextView在切换内容时有僵硬。
现在我想要这样的效果
-->新的内容会把旧的内容顶上去

原本想用animation来做，虽然也是顶的效果，但是，还不是我想要的效果。
所以我对TextView做了小的变动，不知道有没有性能缺陷，感觉还可以。
效果图：
![](http://osswb.oss-cn-shanghai.aliyuncs.com/image/20160604211333.gif)

制作思路：
-->既然是切换，当然需要2个视图，关键在于如何获取旧的视图
-->有了2个视图，不管什么切换效果都是实现的

遇到的坑：
原本是想用View.getdrawingcache();但是一直获取不到正确的视图。网上的各个方法也使用了，但是View内部来获取drawingcache一直返回是初始的bitmap，一直不变。也就造成尴尬的事，每次切换动画，都是与初始值来切换。以为getdrawingcache（）这个方法有问题。但是在外部获取又一切正常。不知道什么原因。所以想到另一个办法，就是把上一个视图直接转成bitmap。

直接上代码
```java
public class WbTextView extends TextView {
    private int mOffsetY = 0;
    public Bitmap lastBitmap;

    public WbTextView(Context context) {
        super(context);
    }

    public WbTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (lastBitmap != null) {
            //绘制位置关系
            canvas.drawBitmap(lastBitmap, 0, mOffsetY - getHeight(), null);
            canvas.translate(0, mOffsetY);
        }
        super.onDraw(canvas);

        if (mOffsetY == 0) {
            //对上个视图做个快照Bitmap
            lastBitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);
            super.onDraw(new Canvas(lastBitmap));
        }
    }

    @Override
    public void setText(CharSequence text, BufferType type) {
        mOffsetY = getHeight();
        post(new Runnable() {
            @Override
            public void run() {
                if (mOffsetY > 0) {
                    //不断减少偏移值
                    mOffsetY -= 5;
                    if (mOffsetY < 0) mOffsetY = 0;
                    postDelayed(this, 10);
                } else {
                    mOffsetY = 0;
                }
                invalidate();
            }
        });
        super.setText(text, type);
    }
}
```
其实也没动多少代码，就是在setText处执行一个Runnable来变化偏移值。
然后在onDraw处根据偏移值来画出动画效果，顺便做一个视图快照。

总结：
总的来说还是比较简洁的，感觉也是一个不错的思路，以后定制效果时也算是一个不错的思路。