刚开始制作前以为很容易，以为对draw()有一点了解，只是重写一下就会实现。不过现实是，搞了两三天，才写出来的。
不过也并不是没有收获。对Bitmap对象到是了解的更深了。还有对图片相交模式也是初次相识。以后要仔细对相交模式研究下，确实是强大功能。

参考技术博客
[图片相交模式讲解](http://mobile.51cto.com/aprogram-452090.htm "")

[参考](http://blog.csdn.net/alan_biao/article/details/17379925 "")

以下是实现原理，考虑可以使用到系统ImageView定义的方法和属性，选择直接继承ImageView。
当然，需要整成控件需要诸多考虑，这边就不贴了，只看最核心的代码。
```java
public class RoundImageView extends ImageView {

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        int width = getWidth();
        int height = getHeight();

        //通过查看ImageView源码，可以知道最终图片会转
        //获取ImageView源drawable，并转换为Bitmap对象
        Bitmap bitMap = ((BitmapDrawable) getDrawable()).getBitmap();
        //图片缩放至当前画布大小
        Bitmap imgBitmap = Bitmap.createScaledBitmap(bitMap, width, height, true);
        //利用上面的imgBitmap对象创建画布
        Canvas imgCanvas = new Canvas(imgBitmap);

        //创建要与原图相交的图片，
        Bitmap shapeBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        //在中心画个默认颜色的圆，其他部分是透明
        new Canvas(shapeBitmap).drawCircle(width / 2, height / 2, width / 2, new Paint());

        //下面是比较重要的一步，new一个画笔，
        // 并设置相交模式为DST_IN
        //什么意思 --> DST 表示底下一层图(一个方形图片)
        //        --> SRC 表示上面一层图(一个中间有像素，四角透明图)
        //        --> DST_IN 表示取 DST和SRC相交部分的DST图，其他部分则透明
        Paint paint = new Paint();
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
        imgCanvas.drawBitmap(shapeBitmap, 0, 0, paint);
        //这时imgCanvas表示的图相就是圆形的图片，且四周透明的


        //这是用这张生成的 imgBitmap 覆盖到原ImageView上面
        canvas.drawBitmap(imgBitmap, 0, 0, new Paint());
    }
}

```
代码中基本都做了注释，还是比较详细的，个人觉得应该最简单的代码量的。如果上面原理动了话，其他任何图形应该都不是难事。