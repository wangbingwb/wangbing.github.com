基于回调的事件处理在理解上可能需要对比监听事件处理的方式。
监听机制涉及3个对象：“**事件源**”，“**事件**”，“**监听器**”，
而回调机制只涉及:“**事件源**”，“**事件**”,
因为这里的监听器统一到了事件源里，也就是说自己来消费事件。
> 举个例子：某个普通单位发生火灾可能需要通知消防署，但是如果某个土豪单位，自己就有“消防署”这个单位，它就可以自己来处理，而不需要去委托他人。

#### 那么安卓中如何去做或如何实现了？
比如View发生触摸事件时，系统会去调用该View的OnTouchEvent(MotionEvent event)；改方法回去通知对应的监听器。那么机会就来了，如果我们不去调用监听器，而是在该方法中直接执行我们的事件处理代码，不是也可以实现嘛?

js中可以动态去为某个元素添加事件函数，但是在java是静态语言，不能如js一样来动态的添加方法，因此只能通过集成View，并重写该View的OnTouchEvent(MotionEvent event)的方法。

#### 如下简单实例：
```java
    public class MyButton extends Button{

        public MyButton(Context context) {
            super(context);
        }

        @Override
        public boolean onKeyDown(int keyCode, KeyEvent event) {
            super.onKeyDown(keyCode, event);

            //这边写上处理代码

            //返回true表示已消费，不再继续传播
            return true;
        }
    }
```