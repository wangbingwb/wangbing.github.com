因为使用的是Android Studio，所以给出jar包引用的版本
`compile 'eu.the4thfloor.volley:com.android.volley:2015.05.28'`
网络框架无非就对网络请求的封装，以下直接给出最简单的用法示例。

#### 普通json数据请求
        {
            RequestQueue requestQueue = Volley.newRequestQueue(this);
            requestQueue.add(new JsonObjectRequest(Request.Method.GET, "http://wangbingwb.github.io/wb/list.json", null, new Response.Listener<JSONObject>() {
                @Override
                public void onResponse(JSONObject response) {
                    Logger.i("-->" + response);
                }
            }, null));
            requestQueue.start();
        }
>一般情况下都有一个RequestQueue请求列队，我们将所有的网络请求add进去即可。



#### 普通的网络图片加载
        {
            RequestQueue requestQueue = Volley.newRequestQueue(this);
            requestQueue.add(new ImageRequest("https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=827046166,2797765950&fm=58", new Response.Listener<Bitmap>() {
                @Override
                public void onResponse(Bitmap response) {
                    img.setImageBitmap(response);
                }
            }, 0, 0, ImageView.ScaleType.FIT_XY, Bitmap.Config.ARGB_8888, null));
            requestQueue.start();
        }
>这种方式加载网络图片其实是最普通的，没有做任何缓存优化，只要请求一次则会发生一次网络请求。因此会大大增加网络流量。

#### 使用ImageLoader加载网络图片
        {
            RequestQueue requestQueue = Volley.newRequestQueue(this);
            ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(img, R.drawable.zh_1, R.drawable.zh_1);
            ImageLoader imageLoader = new ImageLoader(requestQueue, new ImageLoader.ImageCache() {
                @Override
                public Bitmap getBitmap(String url) {
                    return null;
                }

                @Override
                public void putBitmap(String url, Bitmap bitmap) {

                }
            });
            imageLoader.get("https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1889789971,2360758735&fm=58", imageListener);
        }
>与上一个加载网络图片方式有很大的不同，它多了几个重要的对象ImageListener和ImageCache，前者从名称就可以看出是加载时的一个监听器，后者则是为什么图片缓存优化而出现的对象。它有两个方法需要去实现，一个是put，一个是get。顾名思义一个存一个取，而且他是优于网络请求的，就是当可以返回Bitmap对象时，则不会去再次请求网络。

#### 使用NetworkImageView来加载网络图片
        {
            RequestQueue requestQueue = Volley.newRequestQueue(this);
            ImageLoader imageLoader = new ImageLoader(requestQueue, new ImageLoader.ImageCache() {
                @Override
                public Bitmap getBitmap(String url) {
                    return null;
                }

                @Override
                public void putBitmap(String url, Bitmap bitmap) {

                }
            });
            networkImageView.setImageUrl("https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1889789971,2360758735&fm=58", imageLoader);
        }
>与上一个很类似，基本上是对上一个方法的较全面的封装。