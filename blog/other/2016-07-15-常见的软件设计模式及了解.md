#### 什么是设计模式
详细的解释到处可以查到。这里我就以我自己理解的方式表述一下：
`所谓设计模式就是在不断重复事件中总结出的可以复用的一个解决方案。`
好吧！有种前人栽树，后人乘凉的感觉。都是前人不断重复，不断填坑中发现的解决事件的方法或模式。大概有了那么点感觉。

#### 整理一些常用的设计模式指不定什么时候自己套用到了!

------------


#### MVC设计模式
这好像是很普及化的一种设计模式了，软件设计中使用较多，特别是网站开发过程中用到的尤其多。很多的MVC框架都使用了该设计思想。

MVC全名是Model View Controller。
M是指业务模型
V是指用户界面
C则是控制器

MVC 有助于分层管理，因为您可以在一个时间内专门关注一个方面。不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。达到了很好的低耦合性


#### 单例模式
单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

1. 懒汉式单例
仅在第一次调用的时候实例化自己

例如:
```java
public class Singleton {
    private Singleton() {}
    private static Singleton single=null;
    //静态工厂方法
    public static Singleton getInstance() {
         if (single == null) {
             single = new Singleton();
         }
        return single;
    }
}
```
2. 饿汉式单例
在类初始化时，已经自行实例化
例如:

```java
public class Singleton1 {
    private Singleton1() {}
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法
    public static Singleton1 getInstance() {
        return single;
    }
}
```


#### 代理模式(Proxy)
当客户端代码需要调用某个对象时，客户端实际上不关心是否准确得到该对象，它只要一个能提供该功能的对象即可，此时我们就可返回该对象的代理（Proxy）

很容易理解:直接看例子就懂了
```java
public class ImageProxy implements Image
{
    //组合一个image实例，作为被代理的对象
    private Image image;
    //使用抽象实体来初始化代理对象
    public ImageProxy(Image image){
       this.image = image;
    }

    public void show()
    {
       //只有当真正需要调用image的show方法时才创建被代理对象
       if (image == null)
       {
           image = new BigImage();
       }
       image.show();
    }
}

```

#### Factory工厂模式
实例化对象模式了，是用工厂方法代替new操作的一种模式。
工厂模式的好处就是为系统结构提供灵活的动态扩展机制。减速少工作量,方便维护。

角色:
1.     工厂类
2.     抽象产品
3.     具体产品

例子:
```java
//抽象产品
public interface Food {
    void name();
}
//具体产品
public class Apple implements Food {
    @Override
    public void name() {
        System.out.println("Apple....");
    }
}
//工厂类
public class DefaultFactory{
    public Food create(int type) {
        if (type == 1){
            return new Apple();
        }
    }
}
```

工厂模式又可细分为以下模式
1.简单工厂模式（Simple Factory）
简单工厂模式又称静态工厂方法模式。定义一个用于创建对象的接口。

2.工厂方法模式（Factory Method）
工厂方法模式是简单工厂模式的进一步抽象化。
是一种常用的对象创建型设计模式,此模式的核心精神是封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。
角色
1.     抽象工厂
2.     具体工厂
3.     抽象产品
4.     具体产品

例子:
```java
//抽象产品
public interface Food {
    void name();
}
//具体产品1
public class Apple implements Food {
    @Override
    public void name() {
        System.out.println("Apple....");
    }
}
//具体产品2
public class Pear implements Food {
    @Override
    public void name() {
        System.out.println("Pear....");
    }
}

//抽象工厂
public abstract class DefaultFactory {
    abstract Food create();
}
//具体工厂1
public class AppleFactory extends DefaultFactory{
    public Food create() {
        return new Apple();
    }
}
//具体工厂2
public class PearFactory extends DefaultFactory{
    public Food create() {
        return new Pear();
    }
}


```

3.抽象工厂模式（Abstract Factory）
返回一个被实现的接口，至于实现内容外部不需要关心。
角色
    抽象工厂
    具体工厂
    抽象产品
    具体产品


```java
//抽象产品
interface ProductA{
  public void method();
}
//具体产品1
class ProductAF1Impl implements ProductA{
  public void method() {
    System.out.println("厂1 ProductAF1 ...");
  }
}
//具体产品2
class ProductAF2Impl implements ProductA{
  public void method() {
    System.out.println("厂2 ProductAF2 ...");
  }
}

//抽象工厂1、2
abstract class Factory1{
  abstract ProductA getProductA1();
}
abstract class Factory2{
  abstract ProductA getProductA2();
}

//具体的工厂1
class Factory1Impl extends Factory1{
  public ProductA getProductA1() {
    return new ProductA1();
  }
}
//具体的工厂2
class Factory2Impl extends Factory2{
  public ProductA getProductA2() {
    return new ProductA2();
  }
}

//测试类
public class Client {
  public static void main(String[] args) {
    //厂1负责生产产品A1
    Factory1 factory1 = new Factory1Impl();
    ProductA productA1 = factory1.getProductA1();
    productA1.method();

    //厂2负责生产产品A2
    Factory2 factory2 = new Factory2Impl();
    ProductA productA2 = factory2.getProductA2();
    productA2.method();
  }
}
```

